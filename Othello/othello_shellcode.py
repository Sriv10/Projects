import randomimport mathimport time#### Othello Shell#### P. White 2016-2018EMPTY, BLACK, WHITE, OUTER = '.', '@', 'o', '?'# To refer to neighbor squares we can add a direction to a square.N,S,E,W = -10, 10, 1, -1NE, SE, NW, SW = N+E, S+E, N+W, S+WDIRECTIONS = (N,S,E,W,NE,NW,SE,SW)PLAYERS = {BLACK: "Black", WHITE: "White"}SWITCH = {'@' : 'o', 'o' : '@'}########## ########## ########## ########## ########## ########### The strategy class for your AI# You must implement this class# and the method best_strategy# Do not tamper with the init method's parameters, or best_strategy's parameters# But you can change anything inside this you want otherwise#############################################################class Node():    def __init__ (self, board, move, score = 0, alpha = 0, beta = 0):        self.board = board        self.move = move        self.score = score        self.alpha = alpha        self.beta = beta    def __lt__(self,other):        return self.score < other.scoreclass Strategy():    def __init__(self):        pass    def get_starting_board(self):        board = "?" * 10 + "?........?" * 8 + "?" * 10        board = board[:44] + WHITE + BLACK + board[46:]        board = board[:54] + BLACK + WHITE + board[56:]        return board    def get_pretty_board(self, board):        start = ""        for x in range(11, 89, 10):            start += board[x:x + 8] + "\n"        return start    def opponent(self, player):        return SWITCH[player]    def find_match(self, board, player, direction, index):        op = self.opponent(player)        if board[index + direction] == op:            index = index + direction            while (board[index] == op):                index = index + direction            if (board[index] == player):                return index        return False    def make_move(self, board, player, move):        copy = board        for dir in DIRECTIONS:            if (self.find_match(board, player, dir, move)):                index = move                while (copy[index] != player):                    board = board[:index] + player + board[index + 1:]                    index += dir        return board    def get_valid_moves(self, board, player):        moves = list()        for x in range(11, 91):            found = False            if (board[x] == '.'):                for dir in (DIRECTIONS):                    if (self.find_match(board, player, dir, x)):                        moves.append(x)                        break        return moves    def next_player(self, board, prev_player):        if (len(self.get_valid_moves(board, SWITCH[prev_player])) > 0):            return SWITCH[prev_player]        if (len(self.get_valid_moves(board, prev_player)) > 0):            return prev_player        return None    def score(self, board):        black = board.count(BLACK)        white = board.count(WHITE)        return (black - white)    def weightMoveAndMobility(self, board, player, move):        weight = [            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,            0, 120, -20, 20, 5, 5, 20, -20, 120, 0,            0, -20, -40, -5, -5, -5, -5, -40, -20, 0,            0, 20, -5, 15, 3, 3, 15, -5, 20, 0,            0, 5, -5, 3, 3, 3, 3, -5, 5, 0,            0, 5, -5, 3, 3, 3, 3, -5, 5, 0,            0, 20, -5, 15, 3, 3, 15, -5, 20, 0,            0, -20, -40, -5, -5, -5, -5, -40, -20, 0,            0, 120, -20, 20, 5, 5, 20, -20, 120, 0,            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        ]        # print("Player " + str(player))        if (board[11] == SWITCH[player]):            weight[12] = 100            weight[21] = 100            weight[22] = 100        if (board[18] == player):            weight[17] = 100            weight[28] = 100            weight[27] = 100        if (board[81] == player):            weight[71] = 100            weight[72] = 100            weight[82] = 100        if (board[88] == player):            weight[78] = 100            weight[77] = 100            weight[87] = 100        mult = -1        if (player == BLACK):            mult = 1        if (weight[int(move)] <= -20):            return 10000 * mult + random.random()        if (self.stableEdges(board, move, player) > 0):            return -10000 * mult + random.random()        if (weight[int(move)] == 120):            return -5000 * mult + random.random()        if (weight[int(move)] == 100):            return -3000 * mult + random.random()        return len(self.get_valid_moves(board, player)) * mult + random.random()    def weight(self, board, player, move):        weight = [            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,            0, 5020, -200, 20, 5, 5, 20, -200, 5020, 0,            0, -200, -1000, -5, -5, -5, -5, -1000, -200, 0,            0, 200, -5, 15, 3, 3, 15, -5, 200, 0,            0, 5, -5, 3, 3, 3, 3, -5, 5, 0,            0, 5, -5, 3, 3, 3, 3, -5, 5, 0,            0, 200, -5, 15, 3, 3, 15, -5, 200, 0,            0, -200, -1000, -5, -5, -5, -5, -1000, -200, 0,            0, 5020, -200, 20, 5, 5, 20, -200, 5020, 0,            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        ]        total = 0        for x in range(0, 99):            if (board[x] == BLACK):                total += weight[x]            elif (board[x] == WHITE):                total -= weight[x]        return total    def stablePieces(self, board, player, move):        edges = set()        edges = ([x for x in range(1,82,10)])        edges += ([x for x in range(8,89,10)])        edges += ([x for x in range(1,9)])        edges += ([x for x in range(81,89)])        if (move in edges):            for m in self.get_valid_moves(board, player):                b = self.make_move(board, player, m)                if (b[move] == SWITCH[player]):                    return 99999 #+ self.weight(board, player, move)        else:            return self.weight(board,player,move)            #return (self.weight(board, player, move) / 100) + len(self.get_valid_moves(board, player))    def alphabeta(self, node, player, depth, alpha, beta):        bonus = 0        best = {BLACK: max, WHITE: min}        board = node.board        if (depth == 0):            node.score = self.stablePieces(board, player, node.move) + random.random()            return node        children = []        for m in self.get_valid_moves(board, player):            nextBoard = self.make_move(board, player, m)            nextPlayer = self.next_player(nextBoard, player)            if (nextPlayer == None):                c = Node(nextBoard, m, self.score(nextBoard) * 100000000)                children.append(c)            else:                if (nextPlayer == player):                    bonus = 100000000                c = Node(nextBoard, m)                c.score = self.alphabeta(c, nextPlayer, depth - 1, alpha, beta).score + bonus                children.append(c)            if (player == BLACK):                alpha = max(alpha, c.score)            else:                beta = min(beta, c.score)            if (alpha >= beta):                break        winner = best[player](children)        node.score = winner.score        return (winner)    def alphabeta_strategy(self, board, player, depth=11):        beg = Node(board, 0)        winner = self.alphabeta(beg, player, depth, -999999, 999999)        return winner.move    def best_random_strategy(self, board, player, best_move, still_running):        while (True):            best_move.value = random.choice(self.get_valid_moves(board, player))    def best_strategy(self, board, player, best_move, still_running):        depth = 2        while (True):            board = "".join(board)            best_move.value = self.alphabeta_strategy(board, player, depth)            depth += 1            if (depth > 15):                break################################################ The main game-playing code# You can probably run this without modification################################################import timefrom multiprocessing import Value, Processimport os, signalsilent = False################################################## StandardPlayer runs a single game# it calls Strategy.standard_strategy(board, player)#################################################class StandardPlayer():    def __init__(self):        pass    def play(self):        ### create 2 opponent objects and one referee to play the game        ### these could all be from separate files        ref = Strategy()        black = Strategy()        white = Strategy()        print("Playing Standard Game")        board = ref.get_starting_board()        player = BLACK        strategy = {BLACK: black.minmax_strategy, WHITE: white.random_strategy}        print(ref.get_pretty_board(board))        while player is not None:            move = strategy[player](board, player)            print("Move " + str(move) + str(ref.get_valid_moves(board,player)))            print("Player %s chooses %i" % (player, move))            board = ref.make_move(board, player, move)            print(ref.get_pretty_board(board))            player = ref.next_player(board, player)        print("Final Score %i." % ref.score(board), end=" ")        print("%s wins" % ("Black" if ref.score(board)>0 else "White"))################################################## ParallelPlayer simulated tournament play# With parallel processes and time limits# this may not work on Windows, because, Windows is lame# This calls Strategy.best_strategy(board, player, best_shared, running)##################################################class ParallelPlayer():    def __init__(self, time_limit = 5):        self.black = Strategy()        self.white = Strategy()        self.time_limit = time_limit    def play(self):        ref = Strategy()        print("play")        board = ref.get_starting_board()        player = BLACK        print("Playing Parallel Game")        strategy = lambda who: self.black.best_strategy if who == BLACK else self.white.best_random_strategy        while player is not None:            best_shared = Value("i", -99)            best_shared.value = -99            running = Value("i", 1)            p = Process(target=strategy(player), args=(board, player, best_shared, running))            # start the subprocess            t1 = time.time()            p.start()            # run the subprocess for time_limit            p.join(self.time_limit)            # warn that we're about to stop and wait            running.value = 0            time.sleep(0.01)            # kill the process            p.terminate()            time.sleep(0.01)            # really REALLY kill the process            #if p.is_alive(): os.kill(p.pid, signal.SIGKILL)            # see the best move it found            move = best_shared.value            if not silent: print("move = %i , time = %4.2f" % (move, time.time() - t1))            if not silent:print(board, ref.get_valid_moves(board, player))            # make the move            board = ref.make_move(board, player, move)            if not silent: print(ref.get_pretty_board(board))            player = ref.next_player(board, player)        print("Final Score %i." % ref.score(board), end=" ")        print("%s wins" % ("Black" if ref.score(board) > 0 else "White"))if __name__ == "__main__":    game =  ParallelPlayer(1.0)    #game = StandardPlayer()    game.play()